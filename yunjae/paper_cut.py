# 백준 2630 - 색종이 자르기
# 재귀 연습을 위해 이 문제를 선택했다.

# 색종이 입력부 구현 (2차원 리스트 형태로)
N = int(input())
paper = [list(map(int, input().split())) for _ in range(N)]

# 흰색 색종이와 파란색 색종이의 수를 집계할 준비
white = 0
blue = 0

# r: row(행, 세로). 최소값은 0~최대값은 N(=종이의 폭)
# c: column(열, 가로), 최소값은 0~최대값은 N(=종이의 폭)

def cut_paper(r, c, N):
  global white, blue
  color = paper[r][c] # 시작점의 색깔을 저장한다

  # 세로 및 가로로 탐색하며 색이 바뀌는 지점을 찾는다
  for i in range(r, r+N):
    for j in range(c, c+N):
      if color != paper[i][j]:
        cut_paper(r, c, N//2) # 제4사분면
        cut_paper(r, c+N//2, N//2) # 제1사분면
        cut_paper(r+N//2, c, N//2) # 제3사분면
        cut_paper(r+N//2, c+N//2, N//2) # 제2사분면
        
        return
  
  # global 변수인 white와 blue에 각각의 색을 집계한다
  if color == 0:
    white += 1
  else:
    blue += 1

cut_paper(0, 0, N)
print(white)
print(blue)

'''
종이를 자르거나 피자를 분할하는 등의 문제는 코딩테스트에서 자주 나온다.

만약 그 분할 기준이 재귀적 패턴을 띨 경우에 어떻게 접근하면 좋을지 살펴보자.

1. 색종이 입력부 구현 (2차원 리스트 형태로 입력받는다)
2. 종이조각의 맨 왼쪽 위, 즉 (0, 0)부터 순회를 시작한다. 
   이 색이 0(흰색)이냐 1(다른 색)이냐는 일단 상관 없다.
   순회해 나가면서 색이 바뀌는 것을 탐지하면 그때 종이를 자르면 되니까. 
3. 직전 점의 색과 다른 색깔이 나오면 즉시 4등분한다.
   그리고 다시 재귀적으로 순회하는데, 각 조각의 맨 왼쪽 위부터 다시 순회하도록 한다. 
   처음 재귀를 배울 때는 인덱스를 -1 씩 줄여가거나 +1씩 늘려가며 재귀 탐색을 하는데, 이 경우는 반씩 나누는 거니까 `// 2` 로 줄여가며 탐색하면 된다.
   정사각 행렬이니까, 재귀 조건을 만들어주려면 색종이의 폭인 N을 기준으로 하는 게 가장 무난할 것이다.
   즉 N // 2를 일단 떠올릴 수 있어야 한다.
   또한 파라미터를 3개 줘서, 처음에는 (x, y, N)으로 호출했다가 (x, y, N//2)로 호출하는 방법을 떠올릴 수 있어야 한다.
   문제는, 각 조각의 맨 왼쪽 위를 어떤 인덱스로 접근하느냐는 것이다.
   n // 2만큼 더 가로로 or 더 세로로 멀리 떨어진 지점을 시작점으로 삼아 순회해야 한다. 
   왜냐하면 거기서 종이가 잘리고 새로운 종이가 시작하기 때문이다.
   그런 점은 종이가 잘려나갈 때마다 다음과 같이 3개씩 존재한다.
   a) x, y + N//2 
   b) x + N//2, y
   c) x + N//2, y + N//2
'''
