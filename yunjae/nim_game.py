# 백준 11694 - 님 게임
# https://www.acmicpc.net/problem/11694

# 여러 개의 돌 더미가 있고, 각 더미에는 돌이 일정 개수 있다.
# 두 명이 번갈아 가며 한 더미에서 원하는 개수의 돌을 제거한다.
# 마지막 돌을 가져가는 사람이 이긴다.

# 이 문제의 주의할 점은, 모든 더미가 1이하여서 마지막 돌을 가져가는 사람이 진다는 추가 규칙이 있다는 점이다.
# 이 규칙은 'Misère 님'이라고 부르며, 특수한 규칙의 님 게임에 해당한다.
# 따라서 게임의 룰을 판단하기 위한 변수 flag를 별도로 설정해 주자.

# 실제 게임 예) 
# 더미A에 3개, 더미B에 4개, 더미C에 5개의 돌이 있다.
# 각 더미의 돌 개수를 이진수로 바꾸면 011, 100, 101이다.

# 만약 이 모든 비트를 XOR한 결과가 0이라면, 어느 한 더미도 단독으로 판을 뒤집을 힘이 없다.
# (= 모든 더미가 서로의 영향을 상쇄하고 있다)
# 이는 모든 더미의 돌 개수 배치가 게임적으로 완벽히 균형잡혀 있어 누구도 유리하지 않은, 일종의 '대칭' 상태다.
# 즉, 어떤 더미를 건드리면 균형이 깨지고, 상대(cubelover)가 그걸 다시 0으로 돌릴 수 있다는 뜻.
# 상대방이 실수하지 않는 한, 나(koosaga)는 질 수밖에 없는 상태다.

# 주어진 예시를 XOR해 보면 011; XOR 100 = 111; XOR 101 = 010; 이므로 십진수로 2다.
# 이 결과가 0이 아니라는 것은 현재 판이 비대칭이라는 뜻이고,
# 이를 대칭으로 바꿔주는 수가 존재한다는 뜻이다.
# 즉, 현재 판을 XOR = 0 상태로 만드는 수가 반드시 하나 존재하므로, 그 수를 만드는 사람이 이긴다.
# *만약 더미C에서 5 -> 2로 만들면 새 상태는 [3, 4, 2]이고 이를 모두 XOR하면 101(=5)이므로 진다. (X)
# *만약 더미A에서 3 -> 1로 만들면 새 상태는 [1, 4, 5]이고 이를 모두 XOR하면 0이 되므로 이긴다. (O)

import sys
input = sys.stdin.read

# 입력받기
data = list(map(int, input().split()))
n = data[0]    # 수열(돌더미)의 개수
x = 0          # XOR 누적값 (님 게임의 핵심)
flag = False   # XOR 결과가 1보다 큰 적이 있었는지 기록

for t in data[1:n+1]:
    x ^= t               # 이전가지의 XOR 결과에 t를 추가함     
    if x > 1:
        flag = True      # XOR 결과가 한번이라도 2이상이 되었다면 이렇게

# 서로 다른 버전의 님 게임 룰에 따라 승자 판정 (XOR == 0이면 koosaga가 무조건 진다)
if flag:                 # 일반적인 님 게임
    print("cubelover" if x == 0 else "koosaga") 
else:                    # 특수한 규칙의 님 게임(Misère 님 게임처럼 매번 XOR이 0 또는 1만 나온 경우)
    print("cubelover" if x != 0 else "koosaga")
