# 프로그래머스 - 쌍둥이 빌딩 숲
# https://school.programmers.co.kr/learn/courses/30/lessons/140105
# DP 행렬을 만들어 경우의 수를 저장한다.

# dp[i][i] = 1: 모든 높이의 빌딩들이 다 보이는 경우
# dp[i][0] = 0: 빌딩이 하나라도 있다면, 빌딩이 안 보일 수는 없음

# (i, j)는 다음 두 가지 경우의 수의 합이다.
# 1) i-1쌍의 건물로 j-1개의 높이가 보이는 경우: 높이 n인 빌딩이 가장 앞으로 가는 경우는 딱 하나고, 나머지 빌딩 배치의 경우의 수는 (i-1, j-1)
# 이를 정리하면 dp[i+1][j+1] += dp[i][j]
# 2) i-1쌍의 건물로 이미 j개의 높이가 보이는 경우: i쌍을 '보이지 않게' 끼워넣는다면, 2*(i-1)개의 빌딩이 이미 존재할 때, i의 첫째 빌딩과 둘째 빌딩을 사이에 끼울 수 있는 위치는 2(i-1)+1=2i-1 
# 문제는 그 중에서도 i가 보이지 않게 배치해야 한다는 점인데, 그러려면 i보다 작은 건물들 뒤에 위치해야 가려질 것이다. 만약 i가 가장 앞에 온다면 무조건 보이게 되므로 이 경우는 배제한다.
# | 1 | 1 | 2 | 2 |   이렇게 이미 기존의 빌딩이 배치되어 있다면 이 사이에 3, 3이라는 쌍을 끼워넣어야 하는데,
# ↑  ↑  ↑  ↑  ↑
# 0  1  2  3  4
# 3 두 개를 서로 다른 위치에 넣는 경우의 수는, 3의 첫째 빌딩을 1~4중 어딘가 하나에 끼워넣고(2i - 2가지), 그리고 3의 두 번째 빌딩을 그보다 오른쪽에 넣는 것이다. 따라서 2(i - 1)
# 이를 정리하면, dp[i+1][j] = dp[i][j]*2*i

def solution(n, count):
    MAX = 1000000007
    
    dp = [[0]*(n+1) for _ in range(n+1)]
    dp[1][1] = 1
    
    for i in range(1, n):
        for j in range(1, i+1):
            dp[i+1][j+1] += dp[i][j] % MAX
            dp[i+1][j] += dp[i][j]*2*i % MAX
    
    return dp[n][count] % MAX
